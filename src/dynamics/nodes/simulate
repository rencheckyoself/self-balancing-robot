#!/usr/bin/env python

"""
This file is a node to solve for the equations of motion, calculate the state of
the simulated system and publish it at a fixed frequency.

PUBLISHERS:
    /joint_states: (JoinState) the simulated state of the robot
    /hamiltonian: (Float64) the calculated hamiltonian of the system
    /control_force: (Float64) the required control force

"""

import time
import numpy as np
import sympy as sym
from sympy.abc import t
import scipy.linalg

import pickle

import rospy
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64

from dynamics import integrate, Controller

class InertiaProps(object):
    """
    Class to define the inertia tensor of a body. Each input is the respective
    value shown below. The nondiagonal elements are always symetric.

    Ixx Ixy Ixz
        Iyy Iyz
            Izz
    """
    def __init__(self, Ixx, Iyy, Izz, Ixy, Ixz, Iyz):
        self.Ixx = Ixx
        self.Iyy = Iyy
        self.Izz = Izz
        self.Ixy = Ixy
        self.Ixz = Ixz
        self.Iyz = Iyz

class Wheel(object):
    """
    Class to define a wheel.

    Input:
        radius: (double) the radius of the wheel
        mass: (double) the mass of the wheel
        inertia: (InertiaProps) the inertia tensor of the wheel
    """
    def __init__(self, radius, mass, inertia):
        self.radius = radius
        self.mass = mass
        self.inertia = inertia

class Body(object):
    """
    Class to define the robot body. The body is approximated to a 3D rectangle

    Input:
        com_height: (double) The z-distance between the base link and the body center of mass
        wheel_base: (double) The between the two wheels
        mass: (double) mass of the body
        inertia: (InertiaProps) the inertia tensor of the body
    """
    def __init__(self, com_height, wheel_base, mass, inertia):
        self.com_height = com_height
        self.wheel_base = wheel_base
        self.mass = mass
        self.inertia = inertia

class BalanceBot(object):
    """
    Class to simulate a self balancing robot

    Input:
        init_q: (list) The initial position and velocity for each state variable
        having the following syntax:
        (xb, xb_dot, yb, yb_dot, tb, tb_dot, pr, pr_dot, pl, pl_dot, tt, tt_dot)
            xb, yb are the world coordinates of the base link
            tb is the rotation of the base link relative to the world frame
            pr, pl are the position of the right and left wheel respectively
            tt is the rotation of the robot's body relative to the body frame
        wheel: (Wheel) a wheel object that defines the properties of each wheel
        body: (Body) a body object that defines the approximated body
    """
    def __init__(self, init_q, wheel, body):

        self.cur_x = np.array(init_q)

        self.wheel = wheel
        self.body = body


        self.rate = rospy.get_param("frequency")

        self.pub_js = rospy.Publisher("joint_states", JointState, queue_size=1)
        self.pub_ham = rospy.Publisher("hamiltonian", Float64, queue_size=1)
        self.pub_tau = rospy.Publisher("control_force", Float64, queue_size=1)

        self.eom_for_state = [] # List of eqs to calculate acceleration
        self.ham_eq = 0 # Eq to calculate the hamiltonian

        self.ComputeEOM()



    # def xb_acc(x, dx):
    #     """
    #     Equation to calculate the x acceleration of the base link
    #
    #     Input:
    #         x: (double) current x position of the base link
    #         dx: (double) current x velocity of the base link
    #
    #     Output:
    #         ddx: (double) current x acceleration of the base link
    #     """
    #     pass
    #
    # def yb_acc(y, dy):
    #     """
    #     Equation to calculate the y acceleration of the base link
    #
    #     Input:
    #         y: (double) current y position of the base link
    #         dy: (double) current y velocity of the base link
    #
    #     Output:
    #         ddy: (double) current y acceleration of the base link
    #     """
    #     pass
    #
    # def thb_acc(th, dth):
    #     """
    #     Equation to calculate the angular acceleration of the base link
    #
    #     Input:
    #         th: (double) current angular position of the base link
    #         dth: (double) current angular velocity of the base link
    #
    #     Output:
    #         ddth: (double) current angular acceleration of the base link
    #     """
    #     pass
    #
    # def pr_acc(th, dth):
    #     """
    #     Equation to calculate the angular acceleration of the right wheel
    #
    #     Input:
    #         th: (double) current angular position of the right wheel
    #         dth: (double) current angular velocity of the right wheel
    #
    #     Output:
    #         ddth: (double) current angular acceleration of the right wheel
    #     """
    #     pass
    #
    # def pl_acc(th, dth):
    #     """
    #     Equation to calculate the angular acceleration of the left wheel
    #
    #     Input:
    #         th: (double) current angular position of the left wheel
    #         dth: (double) current angular velocity of the left wheel
    #
    #     Output:
    #         ddth: (double) current angular acceleration of the left wheel
    #     """
    #     pass
    #
    # def tht_acc(th, dth):
    #     """
    #     Equation to calculate the angular acceleration of the robot body
    #
    #     Input:
    #         th: (double) current angular position of the robot body
    #         dth: (double) current angular velocity of the robot body
    #
    #     Output:
    #         ddth: (double) current angular acceleration of the robot body
    #     """
    #     pass

    def calc_hamiltonian(self):
        """
        Function to compute the hamiltonian. Used to show help verify the validity
        of the simulation.

        Theoretically the hamiltonian is constant, but the numerical integration
        will create an error over time resulting a changing hamiltonian value.
        If this error is small the simulation is more trustworthy.
        """
        # (0   1       2   3       4   5       6   7       8   9       10  11    )
        # (xb, xb_dot, yb, yb_dot, tb, tb_dot, pr, pr_dot, pl, pl_dot, tt, tt_dot)
        # self.ham = (.5 * self.body.intertia.Iyy * self.cur_x[11]**2) + (.5 * self.left_wheel.inertia.Iyy * self.cur_x[9]**2) + \
        #            (.5 * self.right_wheel.inertia.Iyy * self.cur_x[7]**2)

        ham = self.ham_eq(self.cur_x[0], self.cur_x[1], self.cur_x[2], self.cur_x[3], self.cur_x[4],
                          self.cur_x[5], self.cur_x[6], self.cur_x[7], self.cur_x[8], self.cur_x[9],
                          self.cur_x[10], self.cur_x[11], self.tau)

        self.pub_ham.publish(ham)

    def ComputeEOM(self):
        """
        This function will convert the stored solutions into usable equations of
        motion for a two wheeled, self balancing robot using the parameters
        defined in the robot_params file.

        The end result of this function will be 6 equations to calculate the
        acceleration of each state variable for a given position, velocity, and
        control force. And 1 equation to compute the hamiltonian.
        """

        # Create all symbols to match the solutions - these need to match the SelfBalancing_AllSymbolic.py file
        g = sym.symbols('g')
        lam1, lam2 = sym.symbols('l_1 l_2')

        Xb, Xbd, Xbdd = sym.symbols('x_b x_bd x_bdd')
        Yb, Ybd, Ybdd = sym.symbols('y_b y_bd y_bdd')
        Tb, Tbd, Tbdd = sym.symbols('t_b t_bd t_bdd')
        Pr, Prd, Prdd = sym.symbols('p_r p_rd p_rdd')
        Pl, Pld, Pldd = sym.symbols('p_l p_ld p_ldd')
        Tt, Ttd, Ttdd = sym.symbols('t_t t_td t_tdd')

        F_tht = sym.symbols('F_w')

        wheel_radius, wheel_base, m_wheel = sym.symbols('r_w w_{base} m_w')
        Ixxw, Iyyw, Izzw = sym.symbols('I_{xxw} I_{yyw} I_{zzw}')

        COMz = sym.symbols('h_{com}')
        m_body = sym.symbols('m_b')
        Ixxb, Iyyb, Izzb = sym.symbols('I_{xxb} I_{yyb} I_{zzb}')

        const_subs = {g : 9.81,
                      m_body : self.body.mass, COMz : self.body.com_height,
                      Ixxb : self.body.inertia.Ixx, Iyyb : self.body.inertia.Iyy, Izzb : self.body.inertia.Izz,
                      m_wheel : self.wheel.mass, wheel_radius : self.wheel.radius, wheel_base : self.body.wheel_base,
                      Ixxw : self.wheel.inertia.Ixx, Iyyw : self.wheel.inertia.Iyy, Izzw : self.wheel.inertia.Izz}


        # Import solutions from file
        sols_file = open('/home/michaelrencheck/WinterProject/PrelimTesting/Sols.pickle', 'rb')
        sols = pickle.load(sols_file)
        sols_file.close()

        EOM_xb = sym.Eq(Xbdd, sols[Xbdd].subs(const_subs))
        EOM_yb = sym.Eq(Ybdd, sols[Ybdd].subs(const_subs))
        EOM_tb = sym.Eq(Tbdd, sols[Tbdd].subs(const_subs))
        EOM_pr = sym.Eq(Prdd, sols[Prdd].subs(const_subs))
        EOM_pl = sym.Eq(Pldd, sols[Pldd].subs(const_subs))
        EOM_tt = sym.Eq(Ttdd, sols[Ttdd].subs(const_subs))

        var_list = [Xb, Xbd, Yb, Ybd, Tb, Tbd, Pr, Prd, Pl, Pld, Tt, Ttd, F_tht]
        # lambdify the equations to make them usable functions
        EOM_lxb = sym.lambdify(var_list, EOM_xb.rhs)
        EOM_lyb = sym.lambdify(var_list, EOM_yb.rhs)
        EOM_ltb = sym.lambdify(var_list, EOM_tb.rhs)
        EOM_lpr = sym.lambdify(var_list, EOM_pr.rhs)
        EOM_lpl = sym.lambdify(var_list, EOM_pl.rhs)
        EOM_ltt = sym.lambdify(var_list, EOM_tt.rhs)

        self.eom_for_state = [EOM_lxb, EOM_lyb, EOM_ltb, EOM_lpr, EOM_lpl, EOM_ltt]

        ham_file = open('/home/michaelrencheck/WinterProject/PrelimTesting/Ham.pickle', 'rb')
        ham_sol = pickle.load(ham_file)
        ham_file.close()

        self.ham_eq = sym.lambdify(var_list, ham_sol.subs(const_subs))

    def DynamicsArr(self, cur_loc):
        """
        Function to assemble the array that to be integrated.

        Output:
            pos: (array) the [velocity, acceleration, ...] for each
            state variable. Once integrated the array becomes [position, velocity, ...]
            of each state variable after the specified timestep.
        """

        # calculate the control torque to apply
        self.tau = 0

        # calculate the current accelerations
        acc_calc = np.ones(len(self.eom_for_state))
        for i, eq in enumerate(self.eom_for_state):
            acc_calc[i] = eq(cur_loc[0], cur_loc[1], cur_loc[2], cur_loc[3], cur_loc[4],
                             cur_loc[5], cur_loc[6], cur_loc[7], cur_loc[8], cur_loc[9],
                             cur_loc[10], cur_loc[11], self.tau)

        # assemble the array to integrate
        pos = np.array([cur_loc[1],
                        acc_calc[0],
                        cur_loc[3],
                        acc_calc[1],
                        cur_loc[5],
                        acc_calc[2],
                        cur_loc[7],
                        acc_calc[3],
                        cur_loc[9],
                        acc_calc[4],
                        cur_loc[11],
                        acc_calc[5]])

        return pos

    def Simulate(self):
        """
        The main loop to integrate the Equations of Motion and simulate the
        system based on the set frequency and initial condition.
        """
        r = rospy.Rate(self.rate)
        state = JointState()
        state.name = ['wheel_left_axle, wheel_right_axle']

        while not rospy.is_shutdown():

            self.cur_x = integrate(self.DynamicsArr, self.cur_x, 1./self.rate)
            self.calc_hamiltonian()

            state.header.stamp = rospy.Time.now()
            state.name = ["left_wheel_axle, right_wheel_axle, body_joint"]
            state.position = [self.cur_x[6], self.cur_x[8], self.cur_x[10]]
            # state.velocity = [self.cur_x[7], self.cur_x[9], self.cur_x[11]]


            self.pub_js.publish(state)
            self.pub_tau.publish(self.tau)

            r.sleep()

def main():

    rospy.init_node('simulate')

    wheel_radius = rospy.get_param("wheel_radius")
    wheel_mass = rospy.get_param("wheel_mass")

    body_com = rospy.get_param("body_com_height")
    body_wbase = rospy.get_param("body_wheel_base")
    body_mass = rospy.get_param("body_mass")

    w_inertia = InertiaProps(rospy.get_param("wheel_Ixx"),
                             rospy.get_param("wheel_Iyy"),
                             rospy.get_param("wheel_Izz"),
                             rospy.get_param("wheel_Ixy"),
                             rospy.get_param("wheel_Ixz"),
                             rospy.get_param("wheel_Iyz"))

    b_inertia = InertiaProps(rospy.get_param("body_Ixx"),
                             rospy.get_param("body_Iyy"),
                             rospy.get_param("body_Izz"),
                             rospy.get_param("body_Ixy"),
                             rospy.get_param("body_Ixz"),
                             rospy.get_param("body_Iyz"))

    wheel_obj = Wheel(wheel_radius, wheel_mass, w_inertia)

    body_obj = Body(body_com, body_wbase, body_mass, b_inertia)

    init_state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (np.pi/2 - .1), 0]

    bot = BalanceBot(init_state, wheel_obj, body_obj)

    bot.Simulate()

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
