#!/usr/bin/env python

"""
This file is a node to solve for the equations of motion, calculate the state of
the simulated system and publish it at a fixed frequency.

PUBLISHERS:
    /joint_states: the simulated state of the robot.
"""

import time
import numpy as np
import sympy as sym
from sympy.abc import t
import scipy.linalg

import rospy
from sensor_msgs.msg import JointState

from dynamics import se3ToVec, TransInv, integrate

class InertiaProps(object):
    """
    Class to define the inertia tensor of a body. Each input is the respective
    value shown below. The nondiagonal elements are always symetric.

    Ixx Ixy Ixz
        Iyy Iyz
            Izz
    """
    def __init__(self, Ixx, Iyy, Izz, Ixy, Ixz, Iyz):
        self.Ixx = Ixx
        self.Iyy = Iyy
        self.Izz = Izz
        self.Ixy = Ixy
        self.Ixz = Ixz
        self.Iyz = Iyz

class Controller(object):
    """
    Class to define a PID controller and compute the nessissary controls

    Input:
        kp: (double) proportional gain
        ki: (double) integral gain
        kd: (double) differential gain
        dt: (double) a constant timestep
        set_point: (double) the value the cotroller will drive the system to
    """
    def __init__(self, kp, ki, kd, dt, set_point):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.timestep = dt
        self.set_point = set_point

        self.error = 0

    def compute_control():
        pass

    def change_setpoint(new_val):
        """
        Function to modify the set point

        Input:
            new_val: (double) the new set point
        """
        self.setpoint = new_val

class Wheel(object):
    """
    Class to define a wheel.

    Input:
        radius: (double) the radius of the wheel
        mass: (double) the mass of the wheel
        inertia: (InertiaProps) the inertia tensor of the wheel
    """
    def __init__(self, radius, mass, inertia):
        self.radius = radius
        self.mass = mass
        self.inertia = inertia

class Body(object):
    """
    Class to define the robot body. The body is approximated to a 3D rectangle

    Input:
        length: (double) length of the body between the two wheels
        width: (double) thickness from front to back
        height: (double) height of the body
        mass: (double) mass of the body
        inertia: (InertiaProps) the inertia tensor of the body
    """
    def __init__(self, length, width, height, mass, inertia):
        self.length = length
        self.width = width
        self.height = height
        self.mass = mass
        self.inertia = inertia

class BalanceBot(object):
    """
    Class to simulate a self balancing robot

    Input:
        init_q: (list) The initial position and velocity for each state variable
        having the following syntax:
        (xb, xb_dot, yb, yb_dot, tb, tb_dot, pr, pr_dot, pl, pl_dot, tt, tt_dot)
            xb, yb are the world coordinates of the base link
            tb is the rotation of the base link relative to the world frame
            pr, pl are the position of the right and left wheel respectively
            tt is the rotation of the robot's body relative to the body frame
        left_wheel: (Wheel) a wheel object that defines the left wheel
        right_wheel: (Wheel) a wheel object that defines the right wheel
        body: (Body) a body object that defines the approximated body
    """
    def __init__(self, init_q, left_wheel, right_wheel, body):
        self.rate = rospy.get_param("frequency")
        self.pub = rospy.Publisher("joint_states", JointState, queue_size=1)

        self.eom_for_state =

        self.cur_x = np.array(init_q)

        self.left_wheel = left_wheel
        self.right_wheel = right_wheel
        self.body = body

    def xb_acc(x, dx):
        """
        Equation to calculate the x acceleration of the base link

        Input:
            x: (double) current x position of the base link
            dx: (double) current x velocity of the base link

        Output:
            ddx: (double) current x acceleration of the base link
        """
        pass

    def yb_acc(y, dy):
        """
        Equation to calculate the y acceleration of the base link

        Input:
            y: (double) current y position of the base link
            dy: (double) current y velocity of the base link

        Output:
            ddy: (double) current y acceleration of the base link
        """
        pass

    def thb_acc(th, dth):
        """
        Equation to calculate the angular acceleration of the base link

        Input:
            th: (double) current angular position of the base link
            dth: (double) current angular velocity of the base link

        Output:
            ddth: (double) current angular acceleration of the base link
        """
        pass

    def pr_acc(th, dth):
        """
        Equation to calculate the angular acceleration of the right wheel

        Input:
            th: (double) current angular position of the right wheel
            dth: (double) current angular velocity of the right wheel

        Output:
            ddth: (double) current angular acceleration of the right wheel
        """
        pass

    def pl_acc(th, dth):
        """
        Equation to calculate the angular acceleration of the left wheel

        Input:
            th: (double) current angular position of the left wheel
            dth: (double) current angular velocity of the left wheel

        Output:
            ddth: (double) current angular acceleration of the left wheel
        """
        pass

    def tht_acc(th, dth):
        """
        Equation to calculate the angular acceleration of the robot body

        Input:
            th: (double) current angular position of the robot body
            dth: (double) current angular velocity of the robot body

        Output:
            ddth: (double) current angular acceleration of the robot body
        """
        pass

    def hamiltonian():
        """
        Function to compute the hamiltonian. Used to show help verify the validity
        of the simulation.

        Theoretically H = 0, but the numerical integration will
        create an error over time resulting in H != 0. If this error is small
        the simulation is more trustworthy.
        """
        # (0   1       2   3       4   5       6   7       8   9       10  11    )
        # (xb, xb_dot, yb, yb_dot, tb, tb_dot, pr, pr_dot, pl, pl_dot, tt, tt_dot)
        # self.ham = (.5 * self.body.intertia.Iyy * self.cur_x[11]**2) + (.5 * self.left_wheel.inertia.Iyy * self.cur_x[9]**2) + \
        #            (.5 * self.right_wheel.inertia.Iyy * self.cur_x[7]**2)


        pass

    def ComputeEOM(self):
        """
        This function will compute the equations of motion for a two wheeled, self
        balancing robot using the parameters defined in the robot_params file.

        The end result of this function will be 6 equations to calculate the acceleration
        of each state variable for a given position and velocity.
        """

        # Create all symbols to match the solutions - these need to match the SelfBalancing_AllSymbolic.py file
        g = sym.symbols('g')
        lam1, lam2 = sym.symbols('l_1 l_2')

        # Set Functions
        x_b = sym.Function('xb')(t)
        y_b = sym.Function('yb')(t)
        th_b = sym.Function('thb')(t)
        p_r = sym.Function('pr')(t)
        p_l = sym.Function('pl')(t)
        th_t = sym.Function('tht')(t)

        Xb, Xbd, Xbdd = sym.symbols('x_b x_bd x_bdd')
        Yb, Ybd, Ybdd = sym.symbols('y_b y_bd y_bdd')
        Tb, Tbd, Tbdd = sym.symbols('t_b t_bd t_bdd')
        Pr, Prd, Prdd = sym.symbols('p_r p_rd p_rdd')
        Pl, Pld, Pldd = sym.symbols('p_l p_ld p_ldd')
        Tt, Ttd, Ttdd = sym.symbols('t_t t_td t_tdd')

        F_tht = sym.symbols('F_w')

        wheel_radius, wheel_base, m_wheel = sym.symbols('r_w w_{base} m_w')
        Ixxw, Iyyw, Izzw = sym.symbols('I_{xxw} I_{yyw} I_{zzw}')

        COMz = sym.symbols('h_{com}')
        m_body = sym.symbols('m_b')
        Ixxb, Iyyb, Izzb = sym.symbols('I_{xxb} I_{yyb} I_{zzb}')

        # Import solutions from file
        test_file = open('Sols.pickle', 'rb')
        sols = pickle.load(test_file)
        test_file.close()

        EOM_xb = sym.Eq(Xbdd, sols[Xbdd])
        EOM_yb = sym.Eq(Ybdd, sols[Ybdd])
        EOM_tb = sym.Eq(Tbdd, sols[Tbdd])
        EOM_pr = sym.Eq(Prdd, sols[Prdd])
        EOM_pl = sym.Eq(Pldd, sols[Pldd])
        EOM_tt = sym.Eq(Ttdd, sols[Ttdd])

        # lambdify the equations to make them usable functions
        var_list = [Xb, Xbd, Yb, Ybd, Tb, Tbd, Pr, Prd, Pl, Pld, Tt, Ttd]
        EOM_lxb = sym.lambdify(q_list, EOM_xb.rhs)
        EOM_lyb = sym.lambdify(q_list, EOM_yb.rhs)
        EOM_ltb = sym.lambdify(q_list, EOM_tb.rhs)
        EOM_lpr = sym.lambdify(q_list, EOM_pr.rhs)
        EOM_lpl = sym.lambdify(q_list, EOM_pl.rhs)
        EOM_ltt = sym.lambdify(q_list, EOM_tt.rhs)

        self.eom_for_state = [EOM_lxb, EOM_lyb, EOM_ltb, EOM_lpr, EOM_lpl, EOM_ltt]

    def DynamicsArr(self, cur_loc):
        """
        Function to assemble the array that to be integrated.

        Output:
            pos: (array) the [velocity, acceleration, ...] for each
            state variable. Once integrated the array becomes [position, velocity, ...]
            of each state variable after the specified timestep.
        """
        acc_calc = np.ones(len(self.eom_for_state))

        # calculate the current accelerations
        for i, eq in enumerate(self.eom_for_state):
            index = i*2
            # acc_calc[i] = eq(cur_loc[0], cur_loc[1], cur_loc[2], cur_loc[3], cur_loc[4], cur_loc[5], cur_loc[6], cur_loc[7], cur_loc[8], cur_loc[9], cur_loc[10], cur_loc[11])
            acc_calc[i] = eq(cur_loc[index], cur_loc[index+1])

        # assemble the array to integrate
        pos = np.array([cur_loc[1],
                        acc_calc[0],
                        cur_loc[3],
                        acc_calc[1],
                        cur_loc[5],
                        acc_calc[2],
                        cur_loc[7],
                        acc_calc[3],
                        cur_loc[9],
                        acc_calc[4],
                        cur_loc[11],
                        acc_calc[5]])

        return pos

    def Simulate(self):
        """
        The main loop to integrate the Equations of Motion and simulate the
        system based on the set frequency and initial condition.
        """
        r = rospy.Rate(self.rate)
        state = JointState()
        state.name = ['wheel_left_axle, wheel_right_axle']

        while not rospy.is_shutdown():

            self.cur_x = integrate(self.DynamicsArr, self.cur_x, 1./self.rate)

            state.header.stamp = rospy.Time.now()
            state.position = [self.cur_x[6], self.cur_x[8]]
            # state.velocity = [self.cur_x[7], self.cur_x[9]]

            self.pub.publish(state)

            r.sleep()

def main():

    rospy.init_node('simulate')

    wheel_radius = rospy.get_param("wheel_radius")
    m_wheel = rospy.get_param("wheel_mass")

    length = rospy.get_param("body_height")
    width = rospy.get_param("body_thickness")
    depth = rospy.get_param("body_depth")
    m_body = rospy.get_param("body_mass")

    bot = BalanceBot([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (np.pi/2 - .1), 0])

    bot.ComputeEOM()
    bot.Simulate()

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
